<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive SVG Cognitive Bias Codex</title>

<!-- Tailwind for layout + quick styling -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- GSAP for animations -->
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>

<style>
  :root{
    --bg:#070712;
    --panel:#071026;
    --accent:#06b6d4;
    --muted:#94a3b8;
  }
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(800px 400px at 10% 10%, rgba(6,10,20,0.6), transparent), var(--bg);
    color: #e6eef6;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  /* Canvas */
  .wrap { max-width:1100px; margin:28px auto; padding:18px; }
  header { text-align:center; margin-bottom:18px; }
  h1 { font-size: clamp(20px, 3.5vw, 34px); font-weight:700; letter-spacing:1px; }
  .subtitle{ color:var(--muted); margin-top:6px; }

  /* svg area */
  .canvas { display:flex; gap:20px; align-items:flex-start; justify-content:center; flex-wrap:wrap; }
  .vis {
    width: min(640px, 92vw);
    height: min(640px, 92vw);
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.08));
    border-radius:16px;
    padding:18px;
    box-shadow: 0 30px 80px rgba(2,6,23,0.7);
    display:flex; align-items:center; justify-content:center;
  }

  svg { display:block; width:100%; height:100%; }

  /* slice default styles */
  .slice { cursor:pointer; transform-origin: center center; transition: filter .18s ease; }
  .slice:hover { filter: drop-shadow(0 12px 28px rgba(6,182,212,0.12)); }

  /* label inside circle */
  .center-label { font-weight:700; text-anchor:middle; fill:#e6eef6; font-size:14px; }

  /* panel */
  .panel {
    width:320px; max-width:92vw;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1));
    border-radius:12px;
    padding:16px;
    box-shadow: 0 16px 50px rgba(2,6,23,0.65);
    border: 1px solid rgba(255,255,255,0.03);
  }
  .panel h3 { font-size:18px; margin:0 0 6px 0; }
  .category-badge { display:inline-block; padding:6px 8px; border-radius:999px; background:rgba(6,182,212,0.12); color:var(--accent); font-weight:600; font-size:12px; }
  .bias-item { margin:10px 0; padding:10px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06)); border:1px solid rgba(255,255,255,0.02); }
  .bias-item .name { font-weight:700; }
  .muted { color:var(--muted); font-size:13px; }

  /* cinematic intro overlay */
  .intro-cover { position:fixed; inset:0; z-index:40; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(3,7,12,0.92), rgba(2,6,12,0.97)); }
  .intro-text { color:#dff7fb; text-align:center; font-weight:700; letter-spacing:2px; }
  .small { color:var(--muted); font-weight:500; margin-top:8px; }

  /* responsive */
  @media (max-width:900px){
    .canvas { flex-direction:column; align-items:center; }
    .panel { width:92%; }
  }
</style>
</head>
<body>

<div class="wrap">
  <header>
    <h1>The Cognitive Bias Codex — SVG Interactive</h1>
    <div class="subtitle">Click a slice to zoom and learn. Press <kbd>Esc</kbd> to close, <kbd>←</kbd>/<kbd>→</kbd> to navigate.</div>
  </header>

  <div class="canvas">
    <div class="vis" role="img" aria-label="Interactive cognitive bias codex">
      <!-- SVG viewport -->
      <svg id="codexSVG" viewBox="-320 -320 640 640" xmlns="http://www.w3.org/2000/svg" aria-hidden="false" role="presentation">
        <!-- background circle -->
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>

        <circle r="170" fill="url(#bggrad)" class="base" opacity="0.04"></circle>

        <!-- slices group -->
        <g id="slicesGroup"></g>

        <!-- center label -->
        <g transform="translate(0,0)">
          <text class="center-label" y="6">Cognitive Bias Codex</text>
        </g>
      </svg>
    </div>

    <aside class="panel" id="infoPanel" aria-live="polite">
      <div id="panelEmpty">
        <div class="muted">Select a slice to see biases</div>
      </div>

      <div id="panelContent" style="display:none">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div>
            <div id="panelCat" class="category-badge">Category</div>
            <h3 id="panelTitle" style="margin-top:8px">Title</h3>
          </div>
          <div>
            <button id="prevSlice" title="Previous" class="muted" aria-label="Previous">◀</button>
            <button id="nextSlice" title="Next" class="muted" aria-label="Next">▶</button>
          </div>
        </div>

        <div id="panelList" style="margin-top:12px"></div>
        <div style="margin-top:12px" class="muted">Tip: click other slices or use the arrows to explore.</div>
      </div>
    </aside>
  </div>
</div>

<!-- cinematic intro (hidden after animation) -->
<div id="intro" class="intro-cover" style="opacity:1">
  <div style="text-align:center">
    <div class="intro-text" style="font-size:32px">THE COGNITIVE BIAS CODEX</div>
    <div class="small">A cinematic, interactive learning map</div>
  </div>
</div>

<script>
/* ============================
   Data: categories + biases
   We'll make 8 main slices. Expandable later.
   ============================ */
const categories = [
  { id:0, name:"Too Much Information", color:"#06b6d4", biases: [
    {name:"Anchoring Bias", def:"Rely heavily on first info."},
    {name:"Availability Heuristic", def:"Estimate probability from ease of recall."}
  ]},
  { id:1, name:"Not Enough Meaning", color:"#7c3aed", biases: [
    {name:"Confirmation Bias", def:"Favor info that confirms beliefs."},
    {name:"Clustering Illusion", def:"Seeing patterns in randomness."}
  ]},
  { id:2, name:"Need to Act Fast", color:"#f97316", biases: [
    {name:"Sunk Cost Fallacy", def:"Persist because of past investments."}
  ]},
  { id:3, name:"Social", color:"#ef4444", biases: [
    {name:"Bandwagon Effect", def:"Adopt beliefs because many others do."}
  ]},
  { id:4, name:"Decision", color:"#10b981", biases: [
    {name:"Loss Aversion", def:"Losses hurt more than gains help."}
  ]},
  { id:5, name:"Metacognition", color:"#f43f5e", biases: [
    {name:"Dunning–Kruger Effect", def:"Poor performers overestimate ability."}
  ]},
  { id:6, name:"What Should We Remember?", color:"#60a5fa", biases: [
    {name:"Hindsight Bias", def:"Events seem more predictable after they happen."}
  ]},
  { id:7, name:"Other", color:"#a78bfa", biases: [
    {name:"Confirmation Cascade", def:"Group reinforcement strengthens beliefs."}
  ]}
];

/* Utility: polar arc path for a sector */
function sectorPath(cx, cy, rInner, rOuter, startAngle, endAngle) {
  // angles in radians
  const a0 = startAngle, a1 = endAngle;
  const x0 = cx + rOuter * Math.cos(a0);
  const y0 = cy + rOuter * Math.sin(a0);
  const x1 = cx + rOuter * Math.cos(a1);
  const y1 = cy + rOuter * Math.sin(a1);
  const xi1 = cx + rInner * Math.cos(a1);
  const yi1 = cy + rInner * Math.sin(a1);
  const xi0 = cx + rInner * Math.cos(a0);
  const yi0 = cy + rInner * Math.sin(a0);
  const large = (endAngle - startAngle) > Math.PI ? 1 : 0;
  return [
    `M ${xi0} ${yi0}`,
    `L ${x0} ${y0}`,
    `A ${rOuter} ${rOuter} 0 ${large} 1 ${x1} ${y1}`,
    `L ${xi1} ${yi1}`,
    `A ${rInner} ${rInner} 0 ${large} 0 ${xi0} ${yi0}`,
    `Z`
  ].join(' ');
}

/* Build SVG slices programmatically */
const slicesGroup = document.getElementById('slicesGroup');
const svgSize = 320;
const rInner = 60;
const rOuter = 170;
const cx = 0, cy = 0;
const total = categories.length;
let sliceEls = [];

for(let i=0;i<total;i++){
  const start = (i/total)*Math.PI*2 - Math.PI/2; // offset so first is top
  const end = ((i+1)/total)*Math.PI*2 - Math.PI/2;
  const pathD = sectorPath(cx,cy,rInner,rOuter,start,end);
  const g = document.createElementNS("http://www.w3.org/2000/svg",'g');
  g.setAttribute('data-index', i);
  g.classList.add('slice');
  // color fill with slight gradient-ish via opacity
  const path = document.createElementNS("http://www.w3.org/2000/svg",'path');
  path.setAttribute('d', pathD);
  path.setAttribute('fill', categories[i].color);
  path.setAttribute('fill-opacity', '0.14');
  path.setAttribute('stroke', categories[i].color);
  path.setAttribute('stroke-opacity', '0.18');
  path.setAttribute('stroke-width', '1.4');

  // small decorative arc (inner ring accent)
  const accent = document.createElementNS("http://www.w3.org/2000/svg",'path');
  const innerArc = sectorPath(cx,cy,rInner-6,rInner-2,start + 0.02, end - 0.02);
  accent.setAttribute('d', innerArc);
  accent.setAttribute('fill', 'none');
  accent.setAttribute('stroke', categories[i].color);
  accent.setAttribute('stroke-width', '2');
  accent.setAttribute('stroke-opacity', '0.35');

  // label positioned at middle angle
  const mid = (start+end)/2;
  const lx = cx + (rInner + (rOuter - rInner)/2) * Math.cos(mid);
  const ly = cy + (rInner + (rOuter - rInner)/2) * Math.sin(mid);
  const label = document.createElementNS("http://www.w3.org/2000/svg",'text');
  label.setAttribute('x', lx);
  label.setAttribute('y', ly);
  label.setAttribute('fill', '#dff7fb');
  label.setAttribute('font-size','12');
  label.setAttribute('text-anchor','middle');
  label.setAttribute('dominant-baseline','middle');
  label.setAttribute('pointer-events','none');
  label.textContent = categories[i].name;

  g.appendChild(path);
  g.appendChild(accent);
  g.appendChild(label);
  slicesGroup.appendChild(g);

  sliceEls.push({g, path, label});
}

/* Add inner circle ring */
const svg = document.getElementById('codexSVG');
const innerRing = document.createElementNS("http://www.w3.org/2000/svg",'circle');
innerRing.setAttribute('r','52');
innerRing.setAttribute('fill','rgba(10,15,25,0.42)');
innerRing.setAttribute('stroke','rgba(255,255,255,0.02)');
innerRing.setAttribute('stroke-width','1');
svg.insertBefore(innerRing, slicesGroup);

/* ==============
   Interaction & animations
   ============== */
let activeIndex = null;
const infoPanel = document.getElementById('infoPanel');
const panelContent = document.getElementById('panelContent');
const panelEmpty = document.getElementById('panelEmpty');
const panelTitle = document.getElementById('panelTitle');
const panelCat = document.getElementById('panelCat');
const panelList = document.getElementById('panelList');
const prevSliceBtn = document.getElementById('prevSlice');
const nextSliceBtn = document.getElementById('nextSlice');

/* cinematic intro: build slices with staggered animation */
function introAnimate() {
  const tl = gsap.timeline({defaults:{ease:'power3.out'}});
  // fade in wall
  tl.from('#intro', {opacity:1, duration:0.6});
  // stagger each slice: dash in scale & fade
  sliceEls.forEach((s, idx) => {
    gsap.set(s.g, {opacity:0, scale:0.95, transformOrigin:'center center'});
  });
  tl.to(sliceEls.map(s=>s.g), {opacity:1, scale:1, duration:0.6, stagger:0.08}, '+=0.1');
  // then fade out intro overlay
  tl.to('#intro', {opacity:0, duration:0.6, delay:0.2, onComplete: ()=> document.getElementById('intro').style.display='none'});
}

/* highlight / focus a slice */
function focusSlice(i){
  if(i<0||i>=total) return;
  // reset previous
  sliceEls.forEach((s, idx) => {
    gsap.to(s.g, {scale:1, duration:0.35, ease:'power2.out', filter:'', opacity:1});
    s.path.setAttribute('fill-opacity','0.14');
  });

  // pop the selected one
  const sel = sliceEls[i];
  gsap.to(sel.g, {scale:1.06, duration:0.36, ease:'back.out(1.1)'});
  sel.path.setAttribute('fill-opacity','0.26');

  // populate panel
  openPanelFor(i);
  activeIndex = i;
}

/* open side panel with content for category i */
function openPanelFor(i){
  const cat = categories[i];
  panelEmpty.style.display = 'none';
  panelContent.style.display = 'block';
  panelTitle.textContent = cat.name;
  panelCat.textContent = cat.name;
  // list biases
  panelList.innerHTML = '';
  cat.biases.forEach(b => {
    const el = document.createElement('div');
    el.className = 'bias-item';
    el.innerHTML = `<div class="name">${b.name}</div><div class="muted">${b.def}</div>`;
    panelList.appendChild(el);
  });
}

/* clear panel */
function clearPanel(){
  panelEmpty.style.display = 'block';
  panelContent.style.display = 'none';
  activeIndex = null;
  sliceEls.forEach(s=> gsap.to(s.g, {scale:1, duration:0.22}));
}

/* attach click handlers */
sliceEls.forEach((sObj, idx) => {
  sObj.g.style.cursor = 'pointer';
  sObj.g.addEventListener('click', (ev) => {
    // if already active -> clear
    if(activeIndex === idx){
      clearPanel();
      return;
    }
    focusSlice(idx);
  });

  // hover animations
  sObj.g.addEventListener('mouseenter', ()=> {
    if(activeIndex===idx) return;
    gsap.to(sObj.g, {scale:1.03, duration:0.25});
    gsap.to(sObj.path, {attr:{'fill-opacity':0.22}, duration:0.22});
  });
  sObj.g.addEventListener('mouseleave', ()=> {
    if(activeIndex===idx) return;
    gsap.to(sObj.g, {scale:1, duration:0.22});
    gsap.to(sObj.path, {attr:{'fill-opacity':0.14}, duration:0.22});
  });
});

/* prev/next controls in panel */
prevSliceBtn.addEventListener('click', ()=> {
  let idx = (activeIndex === null) ? 0 : (activeIndex - 1 + total) % total;
  focusSlice(idx);
});
nextSliceBtn.addEventListener('click', ()=> {
  let idx = (activeIndex === null) ? 0 : (activeIndex + 1) % total;
  focusSlice(idx);
});

/* keyboard navigation */
document.addEventListener('keydown', (e) => {
  if(e.key === 'ArrowLeft'){
    let idx = (activeIndex === null) ? 0 : (activeIndex - 1 + total) % total;
    focusSlice(idx);
  }
  if(e.key === 'ArrowRight'){
    let idx = (activeIndex === null) ? 0 : (activeIndex + 1) % total;
    focusSlice(idx);
  }
  if(e.key === 'Escape'){
    clearPanel();
  }
});

/* small accessibility: make slices focusable and navigable by keyboard */
sliceEls.forEach((sObj, idx) => {
  sObj.g.setAttribute('tabindex', '0');
  sObj.g.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); focusSlice(idx); }
  });
});

/* initial cinematic intro */
introAnimate();

/* Resize handling: ensure viewbox stays centered (SVG viewBox used) */
/* (No extra work needed because we used viewBox with center coords) */

</script>
</body>
</html>
